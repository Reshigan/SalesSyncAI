/**
 * Advanced Analytics and Reporting API for SalesSync
 * Real-time dashboards, predictive analytics, and comprehensive reporting
 */

import { Router, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import { AuthenticatedRequest, authMiddleware } from '../../middleware/auth';
import { query, validationResult } from 'express-validator';
import { generatePDF } from '../../utils/pdf-generator';
import { generateExcel } from '../../utils/excel-generator';
import { sendEmail } from '../../services/email-service';
import { cacheMiddleware, clearCache } from '../../middleware/cache';

const router = Router();
const prisma = new PrismaClient();

interface AnalyticsQuery {
  startDate: Date;
  endDate: Date;
  agentIds?: string[];
  customerIds?: string[];
  productIds?: string[];
  territories?: string[];
  metrics: string[];
  groupBy?: 'day' | 'week' | 'month' | 'quarter' | 'year' | 'agent' | 'territory' | 'product';
  compareWith?: 'previous_period' | 'previous_year' | 'budget';
}

interface DashboardMetrics {
  sales: SalesMetrics;
  visits: VisitMetrics;
  performance: PerformanceMetrics;
  trends: TrendAnalysis;
  predictions: PredictiveAnalytics;
  alerts: AlertMetrics;
}

interface SalesMetrics {
  totalRevenue: number;
  totalTransactions: number;
  averageTransactionValue: number;
  growthRate: number;
  topProducts: ProductPerformance[];
  salesByChannel: ChannelPerformance[];
  salesByTerritory: TerritoryPerformance[];
  conversionRate: number;
  revenueByPeriod: TimeSeries[];
}

interface VisitMetrics {
  totalVisits: number;
  completedVisits: number;
  successRate: number;
  averageVisitDuration: number;
  visitsByStatus: StatusBreakdown[];
  visitsByTerritory: TerritoryVisits[];
  visitEfficiency: EfficiencyMetrics;
  customerCoverage: CoverageMetrics;
}

interface PerformanceMetrics {
  agentPerformance: AgentPerformance[];
  territoryPerformance: TerritoryPerformance[];
  productPerformance: ProductPerformance[];
  campaignPerformance: CampaignPerformance[];
  kpiAchievement: KPIAchievement[];
  benchmarkComparison: BenchmarkData[];
}

interface TrendAnalysis {
  salesTrends: TrendData[];
  visitTrends: TrendData[];
  performanceTrends: TrendData[];
  seasonalPatterns: SeasonalPattern[];
  anomalies: AnomalyDetection[];
}

interface PredictiveAnalytics {
  salesForecast: ForecastData[];
  demandPrediction: DemandPrediction[];
  churnPrediction: ChurnPrediction[];
  opportunityScoring: OpportunityScore[];
  resourceOptimization: ResourceOptimization[];
}

interface AlertMetrics {
  performanceAlerts: PerformanceAlert[];
  anomalyAlerts: AnomalyAlert[];
  targetAlerts: TargetAlert[];
  systemAlerts: SystemAlert[];
}

/**
 * Get comprehensive dashboard metrics
 */
router.get('/dashboard',
  authMiddleware,
  cacheMiddleware(300), // 5 minutes cache
  [
    query('startDate').isISO8601().withMessage('Valid start date required'),
    query('endDate').isISO8601().withMessage('Valid end date required'),
    query('agentIds').optional().isArray(),
    query('territories').optional().isArray(),
  ],
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        });
      }

      const {
        startDate,
        endDate,
        agentIds,
        territories
      } = req.query;

      const dateRange = {
        start: new Date(startDate as string),
        end: new Date(endDate as string)
      };

      // Build filters
      const filters = {
        companyId: req.user!.companyId,
        createdAt: {
          gte: dateRange.start,
          lte: dateRange.end
        },
        ...(agentIds && { agentId: { in: agentIds as string[] } }),
        ...(territories && { territory: { in: territories as string[] } })
      };

      // Get comprehensive metrics
      const [
        salesMetrics,
        visitMetrics,
        performanceMetrics,
        trendAnalysis,
        predictiveAnalytics,
        alertMetrics
      ] = await Promise.all([
        getSalesMetrics(filters, dateRange),
        getVisitMetrics(filters, dateRange),
        getPerformanceMetrics(filters, dateRange),
        getTrendAnalysis(filters, dateRange),
        getPredictiveAnalytics(filters, dateRange),
        getAlertMetrics(filters, dateRange)
      ]);

      const dashboardData: DashboardMetrics = {
        sales: salesMetrics,
        visits: visitMetrics,
        performance: performanceMetrics,
        trends: trendAnalysis,
        predictions: predictiveAnalytics,
        alerts: alertMetrics
      };

      res.json({
        success: true,
        data: dashboardData,
        generatedAt: new Date(),
        filters: {
          dateRange,
          agentIds,
          territories
        }
      });

    } catch (error) {
      console.error('Dashboard metrics error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to generate dashboard metrics'
      });
    }
  }
);

/**
 * Get real-time performance metrics
 */
router.get('/realtime',
  authMiddleware,
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      // Get today's real-time metrics
      const [
        todaySales,
        todayVisits,
        activeAgents,
        ongoingActivations,
        systemHealth
      ] = await Promise.all([
        getTodaySalesMetrics(req.user!.companyId),
        getTodayVisitMetrics(req.user!.companyId),
        getActiveAgentsCount(req.user!.companyId),
        getOngoingActivations(req.user!.companyId),
        getSystemHealthMetrics(req.user!.companyId)
      ]);

      const realTimeData = {
        sales: {
          todayRevenue: todaySales.totalRevenue,
          todayTransactions: todaySales.transactionCount,
          hourlyTrend: todaySales.hourlyBreakdown,
          topPerformers: todaySales.topAgents
        },
        visits: {
          plannedVisits: todayVisits.planned,
          completedVisits: todayVisits.completed,
          inProgressVisits: todayVisits.inProgress,
          successRate: todayVisits.successRate
        },
        agents: {
          totalAgents: activeAgents.total,
          activeAgents: activeAgents.active,
          onlineAgents: activeAgents.online,
          performanceDistribution: activeAgents.performanceDistribution
        },
        activations: {
          totalActivations: ongoingActivations.total,
          activeActivations: ongoingActivations.active,
          completedToday: ongoingActivations.completedToday,
          upcomingActivations: ongoingActivations.upcoming
        },
        system: {
          dataSync: systemHealth.syncStatus,
          errorRate: systemHealth.errorRate,
          responseTime: systemHealth.avgResponseTime,
          uptime: systemHealth.uptime
        },
        lastUpdated: new Date()
      };

      res.json({
        success: true,
        data: realTimeData
      });

    } catch (error) {
      console.error('Real-time metrics error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to get real-time metrics'
      });
    }
  }
);

/**
 * Generate advanced analytics report
 */
router.post('/analytics/generate',
  authMiddleware,
  [
    query('reportType').isIn(['sales', 'performance', 'territory', 'product', 'comprehensive']).withMessage('Valid report type required'),
    query('format').isIn(['json', 'pdf', 'excel']).withMessage('Valid format required'),
    query('startDate').isISO8601().withMessage('Valid start date required'),
    query('endDate').isISO8601().withMessage('Valid end date required'),
  ],
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        });
      }

      const {
        reportType,
        format,
        startDate,
        endDate,
        agentIds,
        territories,
        includeCharts,
        includeComparisons,
        emailTo
      } = req.body;

      const analyticsQuery: AnalyticsQuery = {
        startDate: new Date(startDate),
        endDate: new Date(endDate),
        agentIds,
        territories,
        metrics: getMetricsForReportType(reportType),
        groupBy: req.body.groupBy || 'day',
        compareWith: req.body.compareWith
      };

      // Generate comprehensive analytics
      const analyticsData = await generateAdvancedAnalytics(
        req.user!.companyId,
        analyticsQuery
      );

      // Format response based on requested format
      let responseData: any;
      let fileName: string;

      switch (format) {
        case 'pdf':
          const pdfBuffer = await generatePDF({
            title: `${reportType.toUpperCase()} Analytics Report`,
            data: analyticsData,
            includeCharts: includeCharts || false,
            template: `analytics-${reportType}`
          });
          fileName = `analytics-${reportType}-${Date.now()}.pdf`;
          
          res.setHeader('Content-Type', 'application/pdf');
          res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
          return res.send(pdfBuffer);

        case 'excel':
          const excelBuffer = await generateExcel({
            title: `${reportType.toUpperCase()} Analytics Report`,
            data: analyticsData,
            includeCharts: includeCharts || false
          });
          fileName = `analytics-${reportType}-${Date.now()}.xlsx`;
          
          res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
          res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
          return res.send(excelBuffer);

        default:
          responseData = analyticsData;
      }

      // Email report if requested
      if (emailTo) {
        await sendAnalyticsReport(emailTo, analyticsData, format, reportType);
      }

      res.json({
        success: true,
        data: responseData,
        reportType,
        format,
        generatedAt: new Date(),
        parameters: analyticsQuery
      });

    } catch (error) {
      console.error('Generate analytics report error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to generate analytics report'
      });
    }
  }
);

/**
 * Get predictive analytics
 */
router.get('/predictive',
  authMiddleware,
  cacheMiddleware(1800), // 30 minutes cache
  [
    query('predictionType').isIn(['sales', 'demand', 'churn', 'opportunity']).withMessage('Valid prediction type required'),
    query('horizon').isInt({ min: 1, max: 365 }).withMessage('Valid prediction horizon required (1-365 days)'),
  ],
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        });
      }

      const {
        predictionType,
        horizon,
        agentIds,
        territories,
        confidence
      } = req.query;

      const predictionHorizon = parseInt(horizon as string);
      const confidenceLevel = parseFloat(confidence as string) || 0.95;

      let predictions: any;

      switch (predictionType) {
        case 'sales':
          predictions = await generateSalesForecast(
            req.user!.companyId,
            predictionHorizon,
            confidenceLevel,
            { agentIds: agentIds as string[], territories: territories as string[] }
          );
          break;

        case 'demand':
          predictions = await generateDemandPrediction(
            req.user!.companyId,
            predictionHorizon,
            confidenceLevel
          );
          break;

        case 'churn':
          predictions = await generateChurnPrediction(
            req.user!.companyId,
            predictionHorizon,
            confidenceLevel
          );
          break;

        case 'opportunity':
          predictions = await generateOpportunityScoring(
            req.user!.companyId,
            predictionHorizon,
            confidenceLevel
          );
          break;

        default:
          return res.status(400).json({
            success: false,
            error: 'Invalid prediction type'
          });
      }

      res.json({
        success: true,
        data: predictions,
        predictionType,
        horizon: predictionHorizon,
        confidence: confidenceLevel,
        generatedAt: new Date()
      });

    } catch (error) {
      console.error('Predictive analytics error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to generate predictive analytics'
      });
    }
  }
);

/**
 * Get anomaly detection results
 */
router.get('/anomalies',
  authMiddleware,
  [
    query('metric').isIn(['sales', 'visits', 'performance', 'all']).withMessage('Valid metric required'),
    query('sensitivity').isFloat({ min: 0.1, max: 1.0 }).withMessage('Valid sensitivity required (0.1-1.0)'),
  ],
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array()
        });
      }

      const {
        metric,
        sensitivity,
        startDate,
        endDate,
        agentIds
      } = req.query;

      const sensitivityLevel = parseFloat(sensitivity as string) || 0.8;
      const dateRange = {
        start: startDate ? new Date(startDate as string) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
        end: endDate ? new Date(endDate as string) : new Date()
      };

      const anomalies = await detectAnomalies(
        req.user!.companyId,
        metric as string,
        sensitivityLevel,
        dateRange,
        agentIds as string[]
      );

      res.json({
        success: true,
        data: anomalies,
        parameters: {
          metric,
          sensitivity: sensitivityLevel,
          dateRange,
          agentIds
        },
        detectedAt: new Date()
      });

    } catch (error) {
      console.error('Anomaly detection error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to detect anomalies'
      });
    }
  }
);

/**
 * Get custom report builder data
 */
router.post('/custom-report',
  authMiddleware,
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const {
        dimensions,
        metrics,
        filters,
        groupBy,
        orderBy,
        limit,
        includeComparisons,
        includeCharts
      } = req.body;

      // Validate custom report parameters
      const validatedParams = validateCustomReportParams({
        dimensions,
        metrics,
        filters,
        groupBy,
        orderBy,
        limit
      });

      if (!validatedParams.valid) {
        return res.status(400).json({
          success: false,
          error: 'Invalid report parameters',
          details: validatedParams.errors
        });
      }

      // Generate custom report
      const reportData = await generateCustomReport(
        req.user!.companyId,
        validatedParams.params
      );

      // Add comparisons if requested
      if (includeComparisons) {
        reportData.comparisons = await generateComparisons(
          req.user!.companyId,
          validatedParams.params
        );
      }

      // Generate charts if requested
      if (includeCharts) {
        reportData.charts = await generateChartData(reportData.data, validatedParams.params);
      }

      res.json({
        success: true,
        data: reportData,
        parameters: validatedParams.params,
        generatedAt: new Date()
      });

    } catch (error) {
      console.error('Custom report error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to generate custom report'
      });
    }
  }
);

/**
 * Schedule automated report
 */
router.post('/schedule',
  authMiddleware,
  async (req: AuthenticatedRequest, res: Response) => {
    try {
      const {
        reportName,
        reportType,
        schedule,
        recipients,
        format,
        parameters
      } = req.body;

      // TODO: Create scheduled report model in schema
      // For now, just return success without creating the record
      const scheduledReport = {
        id: 'temp-' + Date.now(),
        companyId: req.user!.companyId,
        name: reportName,
        type: reportType,
        schedule: JSON.stringify(schedule),
        recipients: JSON.stringify(recipients),
        format,
        parameters: JSON.stringify(parameters),
        createdBy: req.user!.id,
        active: true
      };

      // Schedule the report job
      await scheduleReportJob(scheduledReport);

      res.json({
        success: true,
        data: {
          reportId: scheduledReport.id,
          name: scheduledReport.name,
          schedule,
          nextRun: calculateNextRun(schedule)
        }
      });

    } catch (error) {
      console.error('Schedule report error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to schedule report'
      });
    }
  }
);

// Helper functions

async function getSalesMetrics(filters: any, dateRange: any): Promise<SalesMetrics> {
  const sales = await prisma.sale.findMany({
    where: filters,
    include: {
      agent: true,
      customer: true,
      items: {
        include: {
          product: true
        }
      }
    }
  });

  const totalRevenue = sales.reduce((sum, sale) => sum + Number(sale.totalAmount), 0);
  const totalTransactions = sales.length;
  const averageTransactionValue = totalTransactions > 0 ? totalRevenue / totalTransactions : 0;

  // Calculate growth rate (compared to previous period)
  const previousPeriodStart = new Date(dateRange.start);
  previousPeriodStart.setDate(previousPeriodStart.getDate() - (dateRange.end.getTime() - dateRange.start.getTime()) / (24 * 60 * 60 * 1000));
  
  const previousSales = await prisma.sale.findMany({
    where: {
      ...filters,
      createdAt: {
        gte: previousPeriodStart,
        lt: dateRange.start
      }
    }
  });

  const previousRevenue = previousSales.reduce((sum, sale) => sum + Number(sale.totalAmount), 0);
  const growthRate = previousRevenue > 0 ? ((totalRevenue - previousRevenue) / previousRevenue) * 100 : 0;

  // Get top products
  const productSales = new Map();
  sales.forEach(sale => {
    sale.items.forEach((item: any) => {
      const productId = item.productId;
      if (!productSales.has(productId)) {
        productSales.set(productId, {
          productId,
          productName: item.product.name,
          quantity: 0,
          revenue: 0
        });
      }
      const product = productSales.get(productId);
      product.quantity += item.quantity;
      product.revenue += item.totalPrice;
    });
  });

  const topProducts = Array.from(productSales.values())
    .sort((a, b) => b.revenue - a.revenue)
    .slice(0, 10);

  // Generate time series data
  const revenueByPeriod = generateTimeSeries(sales, dateRange, 'totalAmount');

  return {
    totalRevenue,
    totalTransactions,
    averageTransactionValue,
    growthRate,
    topProducts,
    salesByChannel: [], // Would implement channel analysis
    salesByTerritory: [], // Would implement territory analysis
    conversionRate: 0, // Would calculate from visits vs sales
    revenueByPeriod
  };
}

async function getVisitMetrics(filters: any, dateRange: any): Promise<VisitMetrics> {
  const visits = await prisma.visit.findMany({
    where: filters,
    include: {
      agent: true,
      customer: true
    }
  });

  const totalVisits = visits.length;
  const completedVisits = visits.filter(v => v.status === 'COMPLETED').length;
  const successRate = totalVisits > 0 ? (completedVisits / totalVisits) * 100 : 0;

  // Calculate average visit duration
  const completedVisitsWithDuration = visits.filter(v => 
    v.status === 'COMPLETED' && v.actualStartTime && v.actualEndTime
  );
  
  const totalDuration = completedVisitsWithDuration.reduce((sum, visit) => {
    const duration = new Date(visit.actualEndTime!).getTime() - new Date(visit.actualStartTime!).getTime();
    return sum + duration;
  }, 0);

  const averageVisitDuration = completedVisitsWithDuration.length > 0 
    ? totalDuration / completedVisitsWithDuration.length / (1000 * 60) // Convert to minutes
    : 0;

  return {
    totalVisits,
    completedVisits,
    successRate,
    averageVisitDuration,
    visitsByStatus: [], // Would implement status breakdown
    visitsByTerritory: [], // Would implement territory breakdown
    visitEfficiency: {} as EfficiencyMetrics, // Would implement efficiency calculations
    customerCoverage: {} as CoverageMetrics // Would implement coverage analysis
  };
}

async function getPerformanceMetrics(filters: any, dateRange: any): Promise<PerformanceMetrics> {
  // Implementation would include comprehensive performance analysis
  return {
    agentPerformance: [],
    territoryPerformance: [],
    productPerformance: [],
    campaignPerformance: [],
    kpiAchievement: [],
    benchmarkComparison: []
  };
}

async function getTrendAnalysis(filters: any, dateRange: any): Promise<TrendAnalysis> {
  // Implementation would include trend analysis algorithms
  return {
    salesTrends: [],
    visitTrends: [],
    performanceTrends: [],
    seasonalPatterns: [],
    anomalies: []
  };
}

async function getPredictiveAnalytics(filters: any, dateRange: any): Promise<PredictiveAnalytics> {
  // Implementation would include ML-based predictions
  return {
    salesForecast: [],
    demandPrediction: [],
    churnPrediction: [],
    opportunityScoring: [],
    resourceOptimization: []
  };
}

async function getAlertMetrics(filters: any, dateRange: any): Promise<AlertMetrics> {
  // Implementation would include alert generation
  return {
    performanceAlerts: [],
    anomalyAlerts: [],
    targetAlerts: [],
    systemAlerts: []
  };
}

function generateTimeSeries(data: any[], dateRange: any, valueField: string): TimeSeries[] {
  const timeSeries: TimeSeries[] = [];
  const dayMs = 24 * 60 * 60 * 1000;
  
  for (let date = new Date(dateRange.start); date <= dateRange.end; date.setTime(date.getTime() + dayMs)) {
    const dayData = data.filter(item => {
      const itemDate = new Date(item.createdAt);
      return itemDate.toDateString() === date.toDateString();
    });
    
    const value = dayData.reduce((sum, item) => sum + (item[valueField] || 0), 0);
    
    timeSeries.push({
      date: new Date(date),
      value,
      count: dayData.length
    });
  }
  
  return timeSeries;
}

// Additional helper functions would be implemented here...

function getMetricsForReportType(reportType: string): string[] {
  const metricsMap: { [key: string]: string[] } = {
    sales: ['revenue', 'transactions', 'conversion_rate', 'average_order_value'],
    performance: ['visit_success_rate', 'sales_per_visit', 'territory_coverage'],
    territory: ['territory_revenue', 'territory_visits', 'territory_agents'],
    product: ['product_sales', 'product_margin', 'product_velocity'],
    comprehensive: ['revenue', 'transactions', 'visits', 'performance', 'territories', 'products']
  };
  
  return metricsMap[reportType] || metricsMap.comprehensive;
}

async function generateAdvancedAnalytics(companyId: string, query: AnalyticsQuery): Promise<any> {
  // Implementation would generate comprehensive analytics based on query
  return {
    summary: {},
    details: {},
    charts: {},
    insights: []
  };
}

// Mock implementations for complex functions
async function getTodaySalesMetrics(companyId: string): Promise<any> {
  return {
    totalRevenue: 15000,
    transactionCount: 45,
    hourlyBreakdown: [],
    topAgents: []
  };
}

async function getTodayVisitMetrics(companyId: string): Promise<any> {
  return {
    planned: 120,
    completed: 85,
    inProgress: 15,
    successRate: 85.5
  };
}

async function getActiveAgentsCount(companyId: string): Promise<any> {
  return {
    total: 25,
    active: 22,
    online: 18,
    performanceDistribution: []
  };
}

async function getOngoingActivations(companyId: string): Promise<any> {
  return {
    total: 8,
    active: 3,
    completedToday: 2,
    upcoming: 3
  };
}

async function getSystemHealthMetrics(companyId: string): Promise<any> {
  return {
    syncStatus: 'healthy',
    errorRate: 0.02,
    avgResponseTime: 150,
    uptime: 99.8
  };
}

// Additional mock implementations...
async function generateSalesForecast(companyId: string, horizon: number, confidence: number, filters: any): Promise<any> {
  return { forecast: [], confidence, horizon };
}

async function generateDemandPrediction(companyId: string, horizon: number, confidence: number): Promise<any> {
  return { predictions: [], confidence, horizon };
}

async function generateChurnPrediction(companyId: string, horizon: number, confidence: number): Promise<any> {
  return { churnRisk: [], confidence, horizon };
}

async function generateOpportunityScoring(companyId: string, horizon: number, confidence: number): Promise<any> {
  return { opportunities: [], confidence, horizon };
}

async function detectAnomalies(companyId: string, metric: string, sensitivity: number, dateRange: any, agentIds: string[]): Promise<any> {
  return { anomalies: [], sensitivity, metric };
}

async function generateCustomReport(companyId: string, params: any): Promise<any> {
  return { data: [], summary: {} };
}

async function generateComparisons(companyId: string, params: any): Promise<any> {
  return { previousPeriod: {}, benchmark: {} };
}

async function generateChartData(data: any, params: any): Promise<any> {
  return { charts: [] };
}

function validateCustomReportParams(params: any): { valid: boolean; errors?: string[]; params?: any } {
  return { valid: true, params };
}

async function scheduleReportJob(report: any): Promise<void> {
  // Implementation would schedule the report job
}

function calculateNextRun(schedule: any): Date {
  return new Date(Date.now() + 24 * 60 * 60 * 1000); // Tomorrow
}

async function sendAnalyticsReport(email: string, data: any, format: string, reportType: string): Promise<void> {
  // Implementation would send email with report
}

// Type definitions
interface TimeSeries {
  date: Date;
  value: number;
  count: number;
}

interface ProductPerformance {
  productId: string;
  productName: string;
  quantity: number;
  revenue: number;
}

interface ChannelPerformance {
  channel: string;
  revenue: number;
  transactions: number;
}

interface TerritoryPerformance {
  territory: string;
  revenue: number;
  visits: number;
  agents: number;
}

interface StatusBreakdown {
  status: string;
  count: number;
  percentage: number;
}

interface TerritoryVisits {
  territory: string;
  planned: number;
  completed: number;
  successRate: number;
}

interface EfficiencyMetrics {
  visitEfficiency: number;
  timeUtilization: number;
  routeOptimization: number;
}

interface CoverageMetrics {
  customerCoverage: number;
  territoryCoverage: number;
  marketPenetration: number;
}

interface AgentPerformance {
  agentId: string;
  agentName: string;
  revenue: number;
  visits: number;
  successRate: number;
  ranking: number;
}

interface CampaignPerformance {
  campaignId: string;
  campaignName: string;
  roi: number;
  engagement: number;
  conversions: number;
}

interface KPIAchievement {
  kpi: string;
  target: number;
  actual: number;
  achievement: number;
}

interface BenchmarkData {
  metric: string;
  value: number;
  benchmark: number;
  variance: number;
}

interface TrendData {
  metric: string;
  trend: 'up' | 'down' | 'stable';
  change: number;
  significance: number;
}

interface SeasonalPattern {
  pattern: string;
  strength: number;
  period: string;
}

interface AnomalyDetection {
  metric: string;
  value: number;
  expected: number;
  severity: 'low' | 'medium' | 'high';
  timestamp: Date;
}

interface ForecastData {
  date: Date;
  predicted: number;
  confidence: number;
  lower: number;
  upper: number;
}

interface DemandPrediction {
  productId: string;
  predictedDemand: number;
  confidence: number;
  factors: string[];
}

interface ChurnPrediction {
  customerId: string;
  churnProbability: number;
  riskFactors: string[];
  recommendedActions: string[];
}

interface OpportunityScore {
  customerId: string;
  score: number;
  potential: number;
  nextBestAction: string;
}

interface ResourceOptimization {
  resource: string;
  currentUtilization: number;
  optimalUtilization: number;
  recommendation: string;
}

interface PerformanceAlert {
  type: string;
  severity: 'low' | 'medium' | 'high';
  message: string;
  affectedEntities: string[];
}

interface AnomalyAlert {
  metric: string;
  anomalyType: string;
  severity: 'low' | 'medium' | 'high';
  description: string;
}

interface TargetAlert {
  target: string;
  achievement: number;
  status: 'on_track' | 'at_risk' | 'missed';
  daysRemaining: number;
}

interface SystemAlert {
  system: string;
  status: 'healthy' | 'warning' | 'critical';
  message: string;
  timestamp: Date;
}

export default router;