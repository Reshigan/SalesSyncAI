import { Router } from 'express';
import { PrismaClient } from '@prisma/client';
import { AuthenticatedRequest, authMiddleware } from '../../middleware/auth';
import simpleRoutes from './simple-routes';

const router = Router();
const prisma = new PrismaClient();

// Use simple routes for now
router.use('/', simpleRoutes);

// Get agent's dashboard data
router.get('/dashboard', authMiddleware, async (req: AuthenticatedRequest, res) => {
  try {
    const agentId = req.user!.id;
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    // Get today's visits
    const todayVisits = await prisma.visit.findMany({
      where: {
        agentId,
        scheduledDate: {
          gte: today,
          lt: tomorrow
        }
      },
      include: {
        customer: {
          select: {
            name: true,
            address: true
          }
        }
      }
    });

    // Get pending surveys
    const pendingSurveys = await prisma.visitSurvey.count({
      where: {
        visit: {
          agentId
        },
        status: 'PENDING'
      }
    });

    // Get current inventory
    const inventory = await prisma.agentInventory.findMany({
      where: { agentId },
      include: {
        product: {
          select: {
            name: true,
            sku: true
          }
        }
      }
    });

    // Get recent sales
    const recentSales = await prisma.sale.findMany({
      where: { agentId },
      take: 5,
      orderBy: { createdAt: 'desc' },
      include: {
        customer: {
          select: {
            name: true
          }
        }
      }
    });

    // Get cash reconciliation status
    const cashReconciliation = await prisma.cashReconciliation.findFirst({
      where: {
        agentId,
        date: today
      }
    });

    res.json({
      success: true,
      data: {
        todayVisits,
        pendingSurveys,
        inventory,
        recentSales,
        cashReconciliation,
        stats: {
          totalVisits: todayVisits.length,
          completedVisits: todayVisits.filter(v => v.status === 'COMPLETED').length,
          pendingSurveys,
          inventoryItems: inventory.length,
          cashReconciled: !!cashReconciliation
        }
      }
    });
  } catch (error) {
    console.error('Error fetching dashboard data:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch dashboard data'
    });
  }
});

// Legacy routes for backward compatibility
/**
 * @swagger
 * /api/field-sales/visits:
 *   get:
 *     summary: Get agent visits
 *     tags: [Field Sales]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Visits retrieved successfully
 */
router.get('/visits', async (req: any, res) => {
  try {
    const { companyId } = req.user;
    const { status, agentId, startDate, endDate } = req.query;

    const where: any = { companyId };
    
    if (status) where.status = status;
    if (agentId) where.agentId = agentId;
    if (startDate || endDate) {
      where.plannedStartTime = {};
      if (startDate) where.plannedStartTime.gte = new Date(startDate as string);
      if (endDate) where.plannedStartTime.lte = new Date(endDate as string);
    }

    const visits = await prisma.visit.findMany({
      where,
      include: {
        customer: {
          select: {
            id: true,
            name: true,
            address: true,
            phone: true,
            email: true
          }
        },
        agent: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        }
      },
      orderBy: { plannedStartTime: 'desc' },
      take: 100
    });

    res.json({
      success: true,
      data: visits,
      meta: {
        total: visits.length,
        filters: { status, agentId, startDate, endDate }
      }
    });
  } catch (error) {
    console.error('Error fetching visits:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch visits'
    });
  }
});

router.post('/visits', async (req: any, res) => {
  try {
    const { companyId, userId } = req.user;
    const { customerId, plannedStartTime, notes, activities } = req.body;

    const visit = await prisma.visit.create({
      data: {
        companyId,
        agentId: userId,
        customerId,
        plannedStartTime: new Date(plannedStartTime),
        status: 'PLANNED',
        notes: notes || '',
        activities: activities || [],
        syncStatus: 'SYNCED'
      },
      include: {
        customer: {
          select: {
            id: true,
            name: true,
            address: true,
            phone: true
          }
        }
      }
    });

    res.status(201).json({
      success: true,
      data: visit
    });
  } catch (error) {
    console.error('Error creating visit:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to create visit'
    });
  }
});

// Stock Management Routes
router.get('/stock', async (req: any, res) => {
  try {
    const { companyId } = req.user;
    const { warehouseId, productId } = req.query;

    const where: any = { companyId };
    if (warehouseId) where.warehouseId = warehouseId;
    if (productId) where.productId = productId;

    const stockItems = await prisma.stockLevel.findMany({
      where,
      include: {
        product: {
          select: {
            id: true,
            name: true,
            sku: true,
            unitPrice: true,
            category: true
          }
        },
        warehouse: {
          select: {
            id: true,
            name: true,
            address: true
          }
        }
      },
      orderBy: { updatedAt: 'desc' }
    });

    res.json({
      success: true,
      data: stockItems
    });
  } catch (error) {
    console.error('Error fetching stock:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch stock'
    });
  }
});

/**
 * @swagger
 * /api/field-sales/stock-draw:
 *   post:
 *     summary: Create stock draw request
 *     tags: [Field Sales]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       201:
 *         description: Stock draw request created
 */
router.post('/stock-draw', async (req: any, res) => {
  try {
    const { companyId, userId } = req.user;
    const { warehouseId, items, notes } = req.body;

    // Create stock draw request
    const stockDraw = await prisma.stockDraw.create({
      data: {
        agentId: userId,
        warehouseId,
        totalValue: 0, // Will be calculated based on items
        status: 'PENDING'
      }
    });

    res.status(201).json({
      success: true,
      data: stockDraw
    });
  } catch (error) {
    console.error('Error creating stock draw request:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to create stock draw request'
    });
  }
});

// Cash Reconciliation Routes
router.get('/cash-reconciliation', async (req: any, res) => {
  try {
    const { companyId, userId } = req.user;
    const { startDate, endDate } = req.query;

    const where: any = { 
      companyId,
      agentId: userId
    };

    if (startDate || endDate) {
      where.date = {};
      if (startDate) where.date.gte = new Date(startDate as string);
      if (endDate) where.date.lte = new Date(endDate as string);
    }

    const reconciliations = await prisma.cashReconciliation.findMany({
      where,
      orderBy: { date: 'desc' },
      take: 30
    });

    res.json({
      success: true,
      data: reconciliations
    });
  } catch (error) {
    console.error('Error fetching cash reconciliations:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch cash reconciliations'
    });
  }
});

/**
 * @swagger
 * /api/field-sales/cash-reconciliation:
 *   post:
 *     summary: Submit daily cash reconciliation
 *     tags: [Field Sales]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       201:
 *         description: Cash reconciliation submitted
 */
router.post('/cash-reconciliation', async (req: any, res) => {
  try {
    const { companyId, userId } = req.user;
    const { 
      date, 
      startingFloat, 
      cashSales, 
      cashReceived, 
      changeGiven, 
      physicalCount,
      expenses,
      variance,
      notes 
    } = req.body;

    const reconciliation = await prisma.cashReconciliation.create({
      data: {
        companyId,
        agentId: userId,
        date: new Date(date),
        startingFloat,
        cashSales,
        cashReceived,
        changeGiven,
        physicalCount,
        expenses: expenses || [],
        variance,
        varianceExplanation: notes || '',
        depositAmount: 0, // Will be calculated
        status: Math.abs(variance) <= 10 ? 'COMPLETED' : 'REQUIRES_APPROVAL',
        depositStatus: 'PENDING'
      }
    });

    res.status(201).json({
      success: true,
      data: reconciliation
    });
  } catch (error) {
    console.error('Error creating cash reconciliation:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to create cash reconciliation'
    });
  }
});

// Customer Management Routes
router.get('/customers', async (req: any, res) => {
  try {
    const { companyId } = req.user;
    const { search, territory } = req.query;

    const where: any = { companyId };
    
    if (search) {
      where.OR = [
        { name: { contains: search as string, mode: 'insensitive' } },
        { email: { contains: search as string, mode: 'insensitive' } },
        { phone: { contains: search as string } }
      ];
    }
    
    if (territory) {
      where.territory = territory;
    }

    const customers = await prisma.customer.findMany({
      where,
      orderBy: { name: 'asc' },
      take: 100
    });

    res.json({
      success: true,
      data: customers
    });
  } catch (error) {
    console.error('Error fetching customers:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch customers'
    });
  }
});

// Sales Routes
router.get('/sales', async (req: any, res) => {
  try {
    const { companyId } = req.user;
    const { startDate, endDate, agentId } = req.query;

    const where: any = { companyId };
    
    if (agentId) where.agentId = agentId;
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt.gte = new Date(startDate as string);
      if (endDate) where.createdAt.lte = new Date(endDate as string);
    }

    const sales = await prisma.sale.findMany({
      where,
      include: {
        customer: {
          select: {
            id: true,
            name: true,
            phone: true
          }
        },
        agent: {
          select: {
            id: true,
            firstName: true,
            lastName: true
          }
        },
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                sku: true
              }
            }
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      take: 100
    });

    res.json({
      success: true,
      data: sales
    });
  } catch (error) {
    console.error('Error fetching sales:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch sales'
    });
  }
});

export default router;