import { Router, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import { AuthenticatedRequest, authMiddleware, requirePermission } from '../../middleware/auth';

const router = Router();
const prisma = new PrismaClient();

// Get warehouses for company
router.get('/', authMiddleware, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const warehouses = await prisma.warehouse.findMany({
      where: { companyId: req.user!.companyId },
      include: {
        _count: {
          select: {
            stockItems: true,
            assignedAgents: true
          }
        }
      }
    });

    res.json({
      success: true,
      data: warehouses
    });
  } catch (error) {
    console.error('Error fetching warehouses:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch warehouses'
    });
  }
});

// Get warehouse stock levels
router.get('/:warehouseId/stock', authMiddleware, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const { warehouseId } = req.params;

    const stockItems = await prisma.stockItem.findMany({
      where: {
        warehouseId,
        warehouse: { companyId: req.user!.companyId }
      },
      include: {
        product: {
          select: {
            id: true,
            name: true,
            sku: true,
            category: true,
            unitPrice: true,
            imageUrl: true
          }
        }
      }
    });

    res.json({
      success: true,
      data: stockItems
    });
  } catch (error) {
    console.error('Error fetching stock:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch stock levels'
    });
  }
});

// Create stock draw request
router.post('/:warehouseId/stock-draw', authMiddleware, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const { warehouseId } = req.params;
    const { items, notes } = req.body;

    // Validate warehouse access
    const warehouse = await prisma.warehouse.findFirst({
      where: {
        id: warehouseId,
        companyId: req.user!.companyId
      }
    });

    if (!warehouse) {
      return res.status(404).json({
        success: false,
        error: 'Warehouse not found'
      });
    }

    // Check agent's draw limits and stock availability
    let totalValue = 0;
    const stockValidation = [];

    for (const item of items) {
      const stockItem = await prisma.stockItem.findFirst({
        where: {
          warehouseId,
          productId: item.productId
        },
        include: { product: true }
      });

      if (!stockItem || stockItem.quantity < item.requestedQuantity) {
        return res.status(400).json({
          success: false,
          error: `Insufficient stock for product ${stockItem?.product.name || item.productId}`
        });
      }

      totalValue += stockItem.product.unitPrice * item.requestedQuantity;
      stockValidation.push({
        productId: item.productId,
        available: stockItem.quantity,
        requested: item.requestedQuantity,
        unitPrice: stockItem.product.unitPrice
      });
    }

    // Create stock draw request
    const stockDrawRequest = await prisma.stockDrawRequest.create({
      data: {
        agentId: req.user!.id,
        warehouseId,
        totalValue,
        status: 'PENDING',
        notes,
        items: {
          create: items.map((item: any) => ({
            productId: item.productId,
            requestedQuantity: item.requestedQuantity,
            unitPrice: stockValidation.find(v => v.productId === item.productId)?.unitPrice || 0
          }))
        }
      },
      include: {
        items: {
          include: {
            product: {
              select: {
                name: true,
                sku: true,
                category: true
              }
            }
          }
        },
        agent: {
          select: {
            firstName: true,
            lastName: true,
            email: true
          }
        }
      }
    });

    // Notify warehouse manager (in real implementation, send notification)
    console.log(`Stock draw request created: ${stockDrawRequest.id} for agent ${req.user!.email}`);

    res.json({
      success: true,
      data: stockDrawRequest
    });
  } catch (error) {
    console.error('Error creating stock draw request:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to create stock draw request'
    });
  }
});

// Approve/reject stock draw request
router.patch('/stock-draw/:requestId', authMiddleware, requirePermission('MANAGE_WAREHOUSE'), async (req: AuthenticatedRequest, res: Response) => {
  try {
    const { requestId } = req.params;
    const { status, notes } = req.body;

    if (!['APPROVED', 'REJECTED'].includes(status)) {
      return res.status(400).json({
        success: false,
        error: 'Invalid status. Must be APPROVED or REJECTED'
      });
    }

    const stockDrawRequest = await prisma.stockDrawRequest.findFirst({
      where: {
        id: requestId,
        warehouse: { companyId: req.user!.companyId }
      },
      include: {
        items: true,
        warehouse: true
      }
    });

    if (!stockDrawRequest) {
      return res.status(404).json({
        success: false,
        error: 'Stock draw request not found'
      });
    }

    if (stockDrawRequest.status !== 'PENDING') {
      return res.status(400).json({
        success: false,
        error: 'Request has already been processed'
      });
    }

    // Update request status
    const updatedRequest = await prisma.stockDrawRequest.update({
      where: { id: requestId },
      data: {
        status,
        approvedBy: req.user!.id,
        approvedAt: new Date(),
        approvalNotes: notes
      }
    });

    // If approved, update stock levels and create agent inventory
    if (status === 'APPROVED') {
      for (const item of stockDrawRequest.items) {
        // Reduce warehouse stock
        await prisma.stockItem.update({
          where: {
            warehouseId_productId: {
              warehouseId: stockDrawRequest.warehouseId,
              productId: item.productId
            }
          },
          data: {
            quantity: {
              decrement: item.requestedQuantity
            }
          }
        });

        // Add to agent's truck inventory
        await prisma.agentInventory.upsert({
          where: {
            agentId_productId: {
              agentId: stockDrawRequest.agentId,
              productId: item.productId
            }
          },
          update: {
            quantity: {
              increment: item.requestedQuantity
            }
          },
          create: {
            agentId: stockDrawRequest.agentId,
            productId: item.productId,
            quantity: item.requestedQuantity
          }
        });
      }
    }

    res.json({
      success: true,
      data: updatedRequest
    });
  } catch (error) {
    console.error('Error processing stock draw request:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to process stock draw request'
    });
  }
});

// Get agent's current inventory
router.get('/agent-inventory', authMiddleware, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const inventory = await prisma.agentInventory.findMany({
      where: { agentId: req.user!.id },
      include: {
        product: {
          select: {
            id: true,
            name: true,
            sku: true,
            category: true,
            unitPrice: true,
            imageUrl: true
          }
        }
      }
    });

    res.json({
      success: true,
      data: inventory
    });
  } catch (error) {
    console.error('Error fetching agent inventory:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch inventory'
    });
  }
});

export default router;